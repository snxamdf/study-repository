package com.study.repository.high.concurrence.aqs;import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;/** * @author * @description * @date 2020/1/15 */@Slf4jpublic class CountDownLatchTest {    static int threadCount = 200;    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        //创建一个计数器        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);        for (int i = 0; i < threadCount; i++) {            int finalI1 = i;            executorService.execute(() -> {                try {                    test(finalI1);                } catch (InterruptedException e) {                    log.error("{}", e.getMessage());                } finally {                    countDownLatch.countDown();                }            });        }        try {            //countDownLatch.await(); //等所有线程执行完            countDownLatch.await(10, TimeUnit.MILLISECONDS);//指定时间，不等所有线程执行完        } catch (InterruptedException e) {            log.error("{}", e.getMessage());        }        log.info("finish");        executorService.shutdown();    }    static void test(int num) throws InterruptedException {        Thread.sleep(100);        log.info("{}", num);    }}