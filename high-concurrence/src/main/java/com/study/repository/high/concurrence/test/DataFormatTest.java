package com.study.repository.high.concurrence.test;import com.study.repository.high.concurrence.annoations.NotThreadSafe;import lombok.extern.slf4j.Slf4j;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;/** * @author * @description * @date 2020/1/15 */@Slf4j@NotThreadSafepublic class DataFormatTest {    private static SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");    static int ct = 5000;    static int tt = 200;    static void update() {        try {            sdf.parse("20200101");        } catch (ParseException e) {            log.error("{}", e.getMessage());        }    }    public static void main(String[] args) throws InterruptedException {        //线程池        ExecutorService executorService = Executors.newCachedThreadPool();        //信号量 允许并发的数        final Semaphore semaphore = new Semaphore(tt);        //计数器        final CountDownLatch countDownLatch = new CountDownLatch(ct);        for (int i = 0; i < ct; i++) {            executorService.execute(() -> {                try {                    semaphore.acquire();                    update();                    semaphore.release();                } catch (InterruptedException e) {                    log.error("{}", e.getMessage());                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();    }}@Slf4jclass ThreadSafeDataFormatTest {    static int ct = 5000;    static int tt = 200;    static void update() {        try {            SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");            sdf.parse("20200101");        } catch (ParseException e) {            log.error("{}", e.getMessage());        }    }    public static void main(String[] args) throws InterruptedException {        //线程池        ExecutorService executorService = Executors.newCachedThreadPool();        //信号量 允许并发的数        final Semaphore semaphore = new Semaphore(tt);        //计数器        final CountDownLatch countDownLatch = new CountDownLatch(ct);        for (int i = 0; i < ct; i++) {            executorService.execute(() -> {                try {                    semaphore.acquire();                    update();                    semaphore.release();                } catch (InterruptedException e) {                    log.error("{}", e.getMessage());                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();    }}@Slf4jclass ThreadSafeDateTimeFormatter {    static int ct = 5000;    static int tt = 200;    private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("yyyyMMdd");    static void update() {        dateTimeFormatter.parseDateTime("20200101").toDate();    }    public static void main(String[] args) throws InterruptedException {        //线程池        ExecutorService executorService = Executors.newCachedThreadPool();        //信号量 允许并发的数        final Semaphore semaphore = new Semaphore(tt);        //计数器        final CountDownLatch countDownLatch = new CountDownLatch(ct);        for (int i = 0; i < ct; i++) {            executorService.execute(() -> {                try {                    semaphore.acquire();                    update();                    semaphore.release();                } catch (InterruptedException e) {                    log.error("{}", e.getMessage());                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();    }}