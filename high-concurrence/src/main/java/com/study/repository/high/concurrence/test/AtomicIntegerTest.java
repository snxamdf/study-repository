package com.study.repository.high.concurrence.test;import com.study.repository.high.concurrence.annoations.Recommend;import com.study.repository.high.concurrence.annoations.ThreadSafe;import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.atomic.AtomicInteger;/** * @author * @description * @date 2020/1/13 */@Slf4j@ThreadSafe@Recommendpublic class AtomicIntegerTest {    static int ct = 1000;    static int tt = 200;    static AtomicInteger count = new AtomicInteger(0);    static void add() {        count.incrementAndGet();    }    public static void main(String[] args) throws InterruptedException {        //线程池        ExecutorService executorService = Executors.newCachedThreadPool();        //信号量 允许并发的数        final Semaphore semaphore = new Semaphore(tt);        //计数器        final CountDownLatch countDownLatch = new CountDownLatch(ct);        for (int i = 0; i < ct; i++) {            executorService.execute(() -> {                try {                    semaphore.acquire();                    add();                    semaphore.release();                } catch (InterruptedException e) {                    log.error("{}", e.getMessage());                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();        log.info("{}   {}", count.get(), countDownLatch.getCount());    }}