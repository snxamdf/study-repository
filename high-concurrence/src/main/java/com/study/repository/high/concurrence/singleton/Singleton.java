package com.study.repository.high.concurrence.singleton;/** * @author * @description * @date 2020/1/14 *///安全发布对象public class Singleton {    private Singleton() {    }    private static Singleton singleton1 = null;    //懒汉模式 线程不安全 多线程下因为有指令重排干扰    public static Singleton getInstance() {        if (singleton1 == null) {            synchronized (Singleton.class) {                if (singleton1 == null) {                    singleton1 = new Singleton();                }            }        }        return singleton1;    }    //线程安全，因为有双重检测机制，防址指令重排干扰    private static volatile Singleton singleton2 = null;    public static Singleton getInstance2() {        if (singleton2 == null) {            synchronized (Singleton.class) {                if (singleton2 == null) {                    singleton2 = new Singleton();                }            }        }        return singleton2;    }    /**     * 枚举模式     * 线程安全，推荐使 用     */    public static Singleton getSingleton1() {        return NewSingleton.INSTANCE.getSingleton();    }    public enum NewSingleton {        INSTANCE;        private Singleton singleton;        //JVM保护这个构造绝对调用一次，且是在这个类调用之前初始化        NewSingleton() {            singleton = new Singleton();        }        public Singleton getSingleton() {            return singleton;        }    }}